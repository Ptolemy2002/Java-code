!SESSION 2019-03-16 14:13:08.466 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Ptolemy\Desktop\Java Code\Java-code\.metadata\.bak_0.log
Created Time: 2019-03-16 14:19:36.883

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:19:36.884
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:19:36.887
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:19:38.541
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt." }};
	public static final HashMap<String, Integer> versionCodes = new HashMap<String, Integer>() {{
		put("1.0", 1);
		put("1.1", value)
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}

	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);

			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:19:38.543
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:19:38.545
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:19:40.141
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt." }};
	public static final HashMap<String, Integer> versionCodes = new HashMap<String, Integer>() {{
		put("1.0", 1);
		put("1.1", 1)
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}

	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);

			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:19:40.143
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:19:40.145
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:18.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<>;

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:18.020
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:18.021
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:20.710
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<> {{}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:20.711
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:20.730
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:21.921
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<> {{
		
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:21.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:21.923
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:24.581
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<> {{
		add
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:24.600
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:24.601
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:26.274
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<> {{
	
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:26.275
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:26.277
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:27.434
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<> {{
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:27.437
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:27.455
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:34.164
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<>() {{
		a
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:34.166
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:34.166
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:39.328
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<String>() {{
		a
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:39.331
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:39.331
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:43.153
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<String>() {{
		add
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:43.156
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:43.156
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:46.854
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<String>() {{
		add("1.0")
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:46.856
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:46.857
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:49.050
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<String>() {{
		add("1.0");
		a
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:49.068
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:49.069
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-16 14:24:53.405
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;

import java.awt.GraphicsEnvironment;
import java.io.Console;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import cards.Card;
import cards.CardPlayer;
import cards.Deck;
import cards.EnumCardNumber;
import cards.EnumCardSuit;
import cards.blackjack.BlackjackGame;

@SuppressWarnings({ "serial", "unchecked" })
public class Main {
	/**
	 * This should be true if running in eclipse, but false otherwise.
	 */
	public static final boolean DEBUG_MODE = false;

	public static Double minBet = 2.0;
	public static Double maxBet = 500.0;
	public static Double minAIBet = 2.0;
	public static Double maxAIBet = 500.0;
	public static Integer maxHits = Integer.MAX_VALUE;
	public static boolean autoSave = true;

	public static String currentDeck = "standard";
	public static Deck deck = Deck.STANDARD_52;
	public static HashMap<String, Deck> decks = new HashMap<>();

	public static BlackjackGame game;
	public static final String PATH = Tools.Variables.getAppdata() + "\\Ptolemy's code\\Blackjack";
	public static final String LAUNCHER_PATH = Tools.Variables.getAppdata()
			+ "\\Ptolemy's code\\Blackjack\\temp\\launcher.bat";
	public static final String VERSION = "1.1";
	public static final int VERSION_CODE = 1;
	public static final String[][] patchNotes = { { "global release" },
			{ "alerts will be made when a player goes bankrupt or goes into debt.", "bug fixes" } };
	public static final ArrayList<String> versionCodes = new ArrayList<String>() {{
		add("1.0");
		add("1.1")
	}};

	public static void testToString() {
		while (true) {
			if (Tools.Console.askBoolean("Would you like to cancel the toString test?", true))
				break;

			EnumCardNumber number = Tools.Console.askSelection("Card Numbers", EnumCardNumber.getValues(), true,
					"CANCEL", true, true, true);
			EnumCardSuit type = Tools.Console.askSelection("Card Types", EnumCardSuit.getValues(), true, "CANCEL", true,
					true, true);

			if (!(number == null || type == null)) {
				System.out.println(new Card(number, type).toString());
			}
		}
	}

	public static void properties() {
		ArrayList<String> properties = new ArrayList<String>() {
			{
				add("minimum bet");
				add("maximum bet");
				add("minimum AI bet");
				add("maximum AI bet");
				add("maximum hits");
			}
		};

		String choice = Tools.Console.askSelection("Properties", properties, true, "Pick a property to edit", "CANCEL",
				true, true, true);
		if (choice != null) {
			switch (choice) {
			case "minumum bet":
				System.out.println("Description: the minimum bet a player can make.");
				System.out.println("\"minimum bet\" is currently $" + minBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum bet\" to " + minBet);
				}
				break;
			case "maximum bet":
				System.out.println("Description: the maximum bet a player can make.");
				System.out.println("\"maximum bet\" is currently $" + maxBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minBet,
							"Bet must be at least the value of \"minumum bet\" ($" + minBet + ")");
					System.out.println("Changed \"maximum bet\" to " + maxBet);
				}
				break;
			case "minimum AI bet":
				System.out.println("Description: the minimum bet an AI can make.");
				System.out.println("\"minimum AI bet\" is currently $" + minAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					minAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 0.01,
							"Bet must be at least 1 penny.");
					System.out.println("Changed \"minumum AI bet\" to $" + minAIBet);
				}
				break;
			case "maximum AI bet":
				System.out.println("Description: the maximum bet an AI can make.");
				System.out.println("\"maximum AI bet\" is currently $" + maxAIBet);
				if (Tools.Console.askBoolean("Would you like to change it?", true)) {
					maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= minAIBet,
							"Bet must be at least the value of \"minumum AI bet\" ($" + minAIBet + ")");
					System.out.println("Changed \"maximum AI bet\" to " + maxAIBet);
				}
				break;
			case "maximum hits":
				System.out.println("Description: the maximum amount of hits a player can make in a turn.");
				System.out.println(
						"\"maximum hits\" is currently " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				if (Tools.Console.askBoolean("Would you like to set it to infinity?", true)) {
					maxHits = Integer.MAX_VALUE;
					System.out.println(
							"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
				} else {
					if (Tools.Console.askBoolean("Would you like to change it?", true)) {
						maxAIBet = Tools.Console.askDouble("What would you like to change it to?", true, x -> x >= 1,
								"Must be at least 1.");
						System.out.println(
								"Changed \"maximum hits\" to " + (maxHits == Integer.MAX_VALUE ? "Infinity" : maxHits));
					}
				}

				break;
			}
		}
	}

	public static void betSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			CardPlayer player = Tools.Console.askSelection("Players", players, true, "Choose a player.", "CANCEL", true,
					true, true);
			if (player != null) {
				if (player.isAI()) {
					if (Tools.Console.askBoolean("Would you like to randomize the bet?", true)) {
						player.makeBet(minAIBet, maxAIBet);
					} else {
						player.setBet(Tools.Console.askDouble(
								player.toString() + "'s bet is $" + player.getBet()
										+ ". What would you like to change it to?",
								true, x -> x >= minAIBet && x <= maxAIBet,
								"The minimum AI bet is $" + minAIBet + ". The maximum AI bet is $" + maxAIBet
										+ " (you can change them in properties)."));
						System.out.println("Changed bet!");
					}
				} else {
					player.setBet(Tools.Console.askDouble(
							player.toString() + "'s bet is $" + player.getBet()
									+ ". What would you like to change it to?",
							true, x -> x >= minBet && x <= maxBet, "The minimum bet is $" + minBet
									+ ". The maximum bet is $" + maxBet + " (you can change them in properties)."));
					System.out.println("Changed bet!");
				}
			}
		}
	}

	public static void playerSetup() {
		ArrayList<CardPlayer> players = game.getPlayers();
		if (players.isEmpty()) {
			System.out.println("There are no players registered.");
		} else {
			if (Tools.Console.askBoolean(
					"There are " + players.size() + " players registered. Would you like to view the players?", true)) {
				Tools.Console.printList(players, true);
			}
		}

		ArrayList<String> choices = new ArrayList<String>() {
			{
				add("add");
			}
		};
		if (!players.isEmpty()) {
			choices.add("remove");
			choices.add("edit");
		}

		String choice = Tools.Console.askSelection("Actions", choices, true,
				"Choose an action (or the index of that action)", "CANCEL", true, true, true);
		if (choice != null) {
			switch (choice) {
			case "add":
				CardPlayer player = game
						.addNewPlayer(Tools.Console.askBoolean("Would you like your player to be an AI?", true));
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player.getName() + "\". Would you like to change it?", true)) {
					player.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean("Your player has $" + player.getMoney() + ". Would you like to change it?",
						true)) {
					if (player.isAI()) {
						player.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player.setMoney(Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
								"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}
				}
				break;
			case "remove":
				players.remove(Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL", true,
						true, true));
				break;
			case "edit":
				CardPlayer player1 = Tools.Console.askSelection("Players", players, true, "Pick a player", "CANCEL",
						true, true, true);
				if (Tools.Console.askBoolean(
						"Your player's name is \"" + player1.getName() + "\". Would you like to change it?", true)) {
					player1.setName(Tools.Console.ask("What is the new name?"));
				}
				if (Tools.Console.askBoolean(
						"Your player has $" + player1.getMoney() + ". Would you like to change it?", true)) {
					if (player1.isAI()) {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minAIBet,
										"The minimum AI bet is $" + minAIBet + " (you can change it in properties)."));
					} else {
						player1.setMoney(
								Tools.Console.askDouble("What is the new money amount?", true, x -> x >= minBet,
										"The minimum bet is $" + minBet + " (you can change it in properties)."));
					}

				}
				break;
			}
		}
	}

	public static void saveDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}
		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			for (String i : decks.keySet()) {
				JSONArray cards = new JSONArray();
				for (Card j : decks.get(i).getCards()) {
					JSONArray card = new JSONArray();
					card.add(j.number.toString());
					card.add(j.suit.toString());
					card.add(j.faceUp);
					cards.add(card);
				}
				decksSave.put(i, cards);
			}
			if (Tools.Files.writeToFile(PATH + "\\decks.json", decksSave.toJSONString())) {
				System.out.println("Successfully saved the decks.");
			} else {
				System.out.println("There was an error writing to the file \"" + PATH + "\\decks.json" + "\"");
			}

		}

	}

	public static void loadDecks() {
		if (!Tools.Files.fileExists(PATH + "\\decks.json")) {
			System.out.println("The decks.json file doesn't exist yet. Initializing it...");
			if (Tools.Files.writeToFile(PATH + "\\decks.json", "{}")) {
				System.out.println("Successfully initialized the decks.json file.");
			} else {
				System.out.println("There was an error initializing the file \"" + PATH + "\\decks.json" + "\"");
			}
		}

		JSONObject decksSave = null;
		try {
			decksSave = (JSONObject) new JSONParser().parse(Tools.Files.readFromFile(PATH + "\\decks.json"));
		} catch (ParseException e) {
		}

		if (decksSave == null) {
			System.out.println("The decks save is either corrupted or not compatible with this verison!");
			if (Tools.Console.askBoolean("Would you like to load defaults (you will lose data)!", true)) {
				Tools.Files.writeToFile(PATH + "\\decks.json", "{}");
				decksSave = new JSONObject();
			}
		}

		if (decksSave != null) {
			decks = new HashMap<String, Deck>();
			for (Object i : decksSave.keySet()) {
				decks.put((String) i, new Deck(new Card[] {}));
				JSONArray cards = (JSONArray) decksSave.get(i);
				for (Object j : cards) {
					if (j instanceof JSONArray) {
						JSONArray card = (JSONArray) j;
						decks.get(i)
								.putCardAtBottom(new Card().setNumber(EnumCardNumber.fromString((String) card.get(0)))
										.setSuit(EnumCardSuit.fromString((String) card.get(1)))
										.setFaceUp((Boolean) card.get(2)));
					} else if (j instanceof String) {
						if (decks.containsKey((String) j)) {
							decks.get(i).appendDeck(decks.get((String) j));
						}
					}
				}
			}
			System.out.println("Successfully loaded the saved decks.");
		}
	}

	public static void loadSave(JSONObject save) {
		game.setMaxHits(((Long) save.get("maxHits")).intValue());
		autoSave = (Boolean) save.get("autoSave");
		minBet = (Double) save.get("minBet");
		maxBet = (Double) save.get("maxBet");
		minAIBet = (Double) save.get("minAIBet");
		maxAIBet = (Double) save.get("maxAIBet");
		loadDecks();
		String temp = (String) save.get("deck");
		if (decks.containsKey(temp)) {
			deck = decks.get(temp);
		} else {
			deck = Deck.STANDARD_52;
		}

		JSONArray players = (JSONArray) save.get("players");
		for (Object i : players) {
			JSONObject data = (JSONObject) i;
			game.addNewPlayer((Boolean) data.get("ai")).setName((String) data.get("name"))
					.setMoney((Double) data.get("money")).setBet((Double) data.get("bet"));
		}
	}

	public static void saveTo(String save, JSONObject value) {
		saveDecks();
		JSONObject latestSave = new JSONObject();
		try {
			latestSave = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
		} catch (ParseException e) {
		}
		for (Object i : value.keySet()) {
			latestSave.put(i, value.get(i));
		}

		if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
			System.out.println("There was an error saving to the save \"" + save + "\"");
		} else {
			System.out.println("Successfully saved to the save file \"" + save + "\"");
		}
	}

	public static void saveToDefault() {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\latest.json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the latest save file!");
			} else {
				System.out.println("Successfully wrote to the latest save file!");
			}
		}
	}

	public static void saveToDefault(String save) {
		saveDecks();
		if (!DEBUG_MODE) {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.getResource("/assets/default.json", Main.class));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		} else {
			JSONObject latestSave = new JSONObject();
			JSONObject defaultSave = new JSONObject();
			try {
				latestSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + save + ".json"));
			} catch (ParseException e) {
			}
			try {
				defaultSave = (JSONObject) new JSONParser()
						.parse(Tools.Files.readFromFile("src\\assets\\default.json"));
			} catch (ParseException e) {
			}

			for (Object i : defaultSave.keySet()) {
				latestSave.put(i, defaultSave.get(i));
			}

			if (!Tools.Files.writeToFile(PATH + "\\saves\\" + save + ".json", latestSave.toJSONString())) {
				System.out.println("There was an error writing to the save file \"" + save + "\"");
			} else {
				System.out.println("Successfully wrote to the save file \"" + save + "\"");
			}
		}
	}

	public static void loadSaveWithErrorCheck(String saveChoice) {
		JSONObject save = null;
		try {
			save = (JSONObject) new JSONParser()
					.parse(Tools.Files.readFromFile(PATH + "\\saves\\" + saveChoice + ".json"));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		if (save == null) {
			System.out.println("There was an error interpreting the save file \"" + saveChoice + "\"");

			if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
				System.out.println("Loading defaults...");
				if (!DEBUG_MODE) {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error writing to the save file!");
					}
				} else {
					if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error writing to the latest save file!");
					}
					// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
				}
			}
		} else {
			try {
				loadSave(save);
			} catch (Exception e) {
				e.printStackTrace();
				System.out.println("The save file is either corrupted or incompatible with this version.");
				if (Tools.Console.askBoolean("Would you like to load the default save (you will lose data)?", true)) {
					System.out.println("Loading defaults...");
					if (!DEBUG_MODE) {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.getResource("/assets/default.json", Main.class))) {
							System.out.println("There was an error writing to the save file!");
						}
					} else {
						if (!Tools.Files.writeToFile(PATH + "\\saves\\" + saveChoice + ".json",
								Tools.Files.readFromFile("src\\assets\\default.json"))) {
							System.out.println("There was an error writing to the latest save file!");
						}
						// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
					}
				}
			}
		}
		System.out.println("Loaded the current data from " + saveChoice + ".json");
	}

	public static JSONObject getCurrentSave() {
		JSONObject res = new JSONObject();
		res.put("autoSave", autoSave);
		res.put("maxHits", maxHits);
		res.put("minBet", minBet);
		res.put("maxBet", maxBet);
		res.put("minAIBet", minAIBet);
		res.put("maxAIBet", maxAIBet);
		res.put("deck", currentDeck);
		res.put("deck", currentDeck);
		res.put("version", VERSION);
		JSONArray players = new JSONArray();
		for (CardPlayer i : game.getPlayers()) {
			JSONObject temp = new JSONObject();
			temp.put("name", i.getName());
			temp.put("ai", i.isAI());
			temp.put("money", i.getMoney());
			temp.put("bet", i.getBet());
			players.add(temp);
		}
		res.put("players", players);

		return res;
	}

	public static void deckEdit() {
		if (Tools.Console.askBoolean("Would you like to create a new deck?", true)) {
			String name = Tools.Console.ask("What is the name of the new deck?", true,
					x -> !x.equals("standard") && !decks.containsKey(x), "Cannot be standard or already existing!");
			decks.put(name, new Deck(new Card[] {}));
			System.out.println("Created an empty deck.");
		} else if (Tools.Console.askBoolean("Would you like to delete a deck?", true)) {
			String d = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);
			if (d != null) {
				decks.remove(d);
				System.out.println("Removed the deck.");
			}
		} else {
			String choice = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
					"Choose a deck to edit.", "CANCEL", true, true, true, false);

			if (choice != null) {
				Deck d = decks.get(choice);
				if (Tools.Console.askBoolean("Would you like to show the contents of this deck?", true)) {
					// Put all cards face up so that user can view them.
					Deck shownDeck = new Deck(d);
					for (Card i : shownDeck.getCards()) {
						i.setFaceUp(true);
					}
					Tools.Console.printList(choice, shownDeck.getCards(), true, 10, "CANCEL");
				}

				ArrayList<String> choices = new ArrayList<String>() {
					{
						add("add");
						add("remove");
						add("append");
						add("delete deck");
						add("append deck");
					}
				};
				String choice1 = Tools.Console.askSelection("Choices", choices, true, "Choose an action to perform.",
						"CANCEL", true, true, true, false);
				if (choice1 != null) {
					switch (choice1) {
					case "add":
						EnumCardSuit suit = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
										x -> x >= Math.min(d.getCards().size(), 1) && x <= d.getCards().size(),
										"Minimun value is 1. Maximum value is " + d.getCards().size());
								d.putCardAt(new Card(number, suit, true), index);
							}
						}
						break;
					case "append":
						EnumCardSuit suit1 = Tools.Console.askSelection("Suits", EnumCardSuit.getValues(), true,
								"Choose a suit for your card.", "CANCEL", true, true, true);
						if (suit1 != null) {
							EnumCardNumber number = Tools.Console.askSelection("Numbers", EnumCardNumber.getValues(),
									true, "Choose a number for your card.", "CANCEL", true, true, true);
							if (number != null) {
								d.putCardAtBottom(new Card(number, suit1, true));
							}
						}
						break;
					case "remove":
						Integer index = Tools.Console.askInt("Choose an index to put your card in.", true,
								x -> x >= 1 && x <= d.getCards().size(),
								"Minimun value is 1. Maximum value is " + d.getCards().size()) - 1;
						d.removeCard(index);
					case "append deck":
						ArrayList<String> deckKeys = new ArrayList<String>(decks.keySet());
						deckKeys.remove(choice);
						deckKeys.add("standard");
						String choice2 = Tools.Console.askSelection("Decks", deckKeys, true, "Choose a deck to append.",
								"CANCEL", true, true, true, false);
						if (choice2 != null) {
							if (!choice2.equals("standard")) {
								d.appendDeck(decks.get(choice2));
							} else {
								d.appendDeck(Deck.STANDARD_52);
							}
						}
						break;
					}
				}

			}
		}
	}
	
	public static void printPatchNotes(String version) {
		for (int i = versionCodes.get(VERSION); i < versionCodes.get(version); i++) {
			System.out.println();
		}
	}
	
	public static void main(String[] args) {
		boolean cont = true;
		if (!(DEBUG_MODE)) {
			Console console = System.console();
			if (console == null && !GraphicsEnvironment.isHeadless()) {
				String filename = Main.class.getProtectionDomain().getCodeSource().getLocation().toString()
						.substring(6);
				try {
					File batch = new File(LAUNCHER_PATH);
					Tools.Files.deleteFile(batch);
					File parent = batch.getParentFile();
					if (!parent.exists() && !parent.mkdirs()) {
						throw new IOException("Couldn't create dir: " + parent);
					}
					batch.createNewFile();
					PrintWriter writer = new PrintWriter(batch);
					writer.println("@echo off");
					writer.println("java -jar " + filename);
					writer.println("exit");
					writer.flush();
					writer.close();
					Runtime.getRuntime().exec("cmd /c start \"\" \"" + batch.getPath() + "\"");
				} catch (IOException e) {
					e.printStackTrace();
				}
				cont = false;
			}
		}

		if (cont) {
			System.out.println("Blackjack v" + VERSION);
			game = new BlackjackGame(deck);
			
			if (!Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
				System.out.println("Welcome to the new version of Blackjack!");
				
			}
			
			if (!DEBUG_MODE) {
				// System.out.println(Tools.Files.readFromFile(PATH + "\\version.txt"));
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.getResource("/assets/default.json", Main.class))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
			} else {
				if (!Tools.Files.fileExists(PATH + "\\saves\\latest.json")
						|| !Tools.Files.fileExists(PATH + "\\version.txt")
						|| !Tools.Files.readFromFile(PATH + "\\version.txt").equals(VERSION)) {
					System.out.println("The latest save file does not yet exist or is not up to date.");
					System.out.println("Initializing it...");
					if (!Tools.Files.writeToFile(PATH + "\\saves\\latest.json",
							Tools.Files.readFromFile("src\\assets\\default.json"))) {
						System.out.println("There was an error initializing the latest save file!");
					} else {
						System.out.println("Initialized!");
					}
				}
				// System.out.println(Tools.Files.readFromFile("src\\assets\\default.json"));
			}

			Tools.Files.writeToFile(PATH + "\\version.txt", VERSION);
			loadSaveWithErrorCheck("latest");
			System.out.println("Welcome to Blackjack!");
			if (Tools.Console.askBoolean("Would you like to hear the rules?", true))
				game.printDescription();
			System.out.println("Okay! Let's go!");
			System.out.println("");

			ArrayList<String> choices = new ArrayList<String>() {
				{
					add("play");
					add("player setup");
					add("properties");
					add("quit");
					add("help");
					add("rules");
					add("bet setup");
					add("bet reset");
					add("save latest");
					add("auto save enable");
					add("auto save disable");
					add("load latest");
					add("save as");
					add("load file");
					add("delete save");
					add("deck edit");
					add("set deck");
					add("deck standard");
					add("restore defaults");
				}
			};

			loop: while (true) {
				game.setMaxHits(maxHits);
				if (autoSave) {
					System.out.println("Auto save is on! Saving to \"latest.json\"...");
					saveTo("latest", getCurrentSave());
				}

				for (CardPlayer i : game.getPlayers()) {
					if (Math.abs(i.getMoney()) < 0.01) {
						System.out.println(i.toString() + " has gone bankrupt!");
					} else if (i.getMoney() < 0) {
						System.out.println(i.toString() + " has gone $" + Math.abs(i.getMoney()) + " into debt!");
					}
				}

				String choice = Tools.Console
						.askSelection("Command Choices", choices, true,
								"What would you like to do (\"help\" for choices)?", null, true, false, false)
						.toLowerCase();
				System.out.println("");
				switch (choice) {
				case "play":
					if (game.getPlayers().isEmpty()) {
						System.out.println("There are no players! Use the \"player setup\" command to add some.");
					} else {
						for (CardPlayer i : game.getPlayers()) {
							if (i.getBet() == 0) {
								System.out.println(i.toString() + " has no bet.");
								if (i.isAI()) {
									i.makeBet(minAIBet, maxAIBet);
								} else {
									i.makeBet(minBet, maxBet);
								}
							}
						}

						game.start();
					}
					break;
				case "quit":
					System.out.println("Goodbye.");
					break loop;
				case "properties":
					properties();
					break;
				case "help":
					System.out.println(
							"play - Play a game. There must be at least one registered player, and all registered players must have bets for this to work.");
					System.out.println(
							"player setup - This command allows you to register, edit, and remove players. You can add an AI or a user. You can also edit the money a player has.");
					System.out.println(
							"By default there is one player called \"Player 1\" and one AI called \"Player 2\", and they both have $500");
					System.out.println("bet setup - This command allows you to override the bet of any player.");
					System.out.println(
							"Set a player's bet to 0 if you would like them to choose at the beginning of a game.");
					System.out.println("properties - edit some global propeerties of the game.");
					System.out.println("rules - read the rules again.");
					System.out.println("help - show this list.");
					System.out.println("quit - end the program.");
					System.out.println("bet reset - Resets all players' bets.");
					System.out.println("save latest - save the current data to the latest save.");
					System.out.println(
							"auto save enable - enable auto save. The computer will save after every change made.");
					System.out.println("auto save disable - disable auto save. You will need to save manually.");
					System.out.println(
							"save as - save as a new save file that you can restore from with the load command");
					System.out.println("load file - load from a save file you have created");
					System.out.println("delete save - delete a save from the file system");
					System.out.println(
							"deck edit - create deck presets and edit the deck that will be used during the game.");
					System.out.println("set deck - set the current deck to be used. Must have length of at least 10.");
					System.out.println("deck standard - load the standard deck.");
					System.out.println(
							"restore defaults - will delete the latest save file and restore default settings.");

					System.out.println("");
					System.out.println(
							"You do not need to specify the entire command. You only need to specify enough to isolate the meaning of your input.");
					break;
				case "rules":
					game.printDescription();
					break;
				case "player setup":
					playerSetup();
					break;
				case "bet setup":
					ArrayList<String> choices1 = new ArrayList<String>() {
						{
							add("automatic");
							add("manual");
						}
					};
					if (Tools.Console.askSelection("Choices", choices1, true,
							"Would you like to use automatic or manual mode?", "CANCEL", true, false, false)
							.equalsIgnoreCase("automatic")) {
						game.makeBets(minBet, maxBet, minAIBet, maxAIBet);
					} else {
						betSetup();
					}
					break;
				case "bet reset":
					for (CardPlayer i : game.getPlayers()) {
						i.setBet(0.0);
						System.out.println("Reset " + i.toString() + "'s bet!");
					}
					break;
				case "auto save enable":
					autoSave = true;
					System.out.println("Auto save has been enabled!");
					break;
				case "auto save disable":
					autoSave = false;
					System.out.println("Auto save has been disabled!");
					break;
				case "save latest":
					Tools.Files.writeToFile(PATH + "\\saves\\latest.json", getCurrentSave().toJSONString());
					System.out.println("Saved the current data to latest.json");
					break;
				case "load latest":
					loadSaveWithErrorCheck("latest");
					break;
				case "save as":
					if (Tools.Console.askBoolean("Would you like to view the current saves?", true)) {
						Tools.Console.printList(Tools.Files.getFilesInFolder(PATH + "\\saves", "json"));
					}
					String save1 = Tools.Console.ask("What save do you want to save to (does not have to exist)?");
					if (save1 != null) {
						saveTo(save1, getCurrentSave());
					}

					break;
				case "load file":
					loadSaveWithErrorCheck(
							Tools.Console.askSelection("Saves", Tools.Files.getFilesInFolder(PATH + "\\saves", "json"),
									true, "Choose a save file to load from (or the index off that save file)", "CANCEL",
									true, true, true));
					break;
				case "delete save":
					String save3 = Tools.Console.askSelection("Save files",
							Tools.Files.getFilesInFolder(PATH + "\\saves", "json"), true,
							"Choose a save file to delete", "CANCEL", true, true, true);
					if (save3 != null) {
						if (Tools.Console.askBoolean(
								"This cannot be undone! Would you still like to delete the save file?", true)) {
							Tools.Files.deleteFile(new File(PATH + "\\saves\\" + save3 + ".json"));
						}
					}
					break;
				case "deck edit":
					deckEdit();
					break;
				case "set deck":
					String choice2 = Tools.Console.askSelection("Decks", new ArrayList<String>(decks.keySet()), true,
							"Choose the deck to use.", "CANCEL", true, true, true);
					currentDeck = choice2;
					deck = decks.get(choice2);
					System.out.println("Successfully changed the deck.");
					break;
				case "deck standard":
					currentDeck = "standard";
					deck = Deck.STANDARD_52;
					break;
				case "restore defaults":
					System.out.println("All of your saves will be kept except the latest one.");
					if (Tools.Console.askBoolean("This cannot be undone! Would you still like to restore defaults?",
							true)) {
						Tools.Files.deleteFile(new File(PATH + "\\saves\\latest.json"));
						System.out.println("A game restart is required.");
						System.out.println("Goodbye.");
						break loop;
					}
					break;
				}
				System.out.println("");
			}
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-16 14:24:53.424
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-16 14:24:53.424
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3298)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:447)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2019-03-17 18:10:09.450 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-17 18:10:24.372
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-17 18:10:24.376
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-17 18:10:36.857
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-17 18:10:42.165
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-03-18 10:31:11.863 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.runtime 4 0 2019-03-18 10:32:08.344
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.epp.mpc.ui/intro/css/marketplace.png
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.epp.mpc.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:203)
	at org.eclipse.ui.internal.menus.MenuHelper.getIconURI(MenuHelper.java:373)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.getImageURL(QuicklinksViewer.java:298)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.processDefinition(QuicklinksViewer.java:228)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.get(QuicklinksViewer.java:179)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.get(QuicklinksViewer.java:1)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.getQuicklinks(QuicklinksViewer.java:494)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.createContent(QuicklinksViewer.java:348)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroContent(IntroHTMLGenerator.java:721)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:345)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroDiv(IntroHTMLGenerator.java:464)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:339)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroDiv(IntroHTMLGenerator.java:464)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:339)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateBodyElement(IntroHTMLGenerator.java:311)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateHTMLElement(IntroHTMLGenerator.java:146)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateHTMLforPage(IntroHTMLGenerator.java:80)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.generateContentForPage(BrowserIntroPartImplementation.java:326)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.dynamicStandbyStateChanged(BrowserIntroPartImplementation.java:585)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.doStandbyStateChanged(BrowserIntroPartImplementation.java:780)
	at org.eclipse.ui.internal.intro.impl.model.AbstractIntroPartImplementation.standbyStateChanged(AbstractIntroPartImplementation.java:256)
	at org.eclipse.ui.internal.intro.impl.model.IntroPartPresentation.standbyStateChanged(IntroPartPresentation.java:445)
	at org.eclipse.ui.intro.config.CustomizableIntroPart.standbyStateChanged(CustomizableIntroPart.java:277)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.lambda$1(ViewIntroAdapterPart.java:117)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.setStandby(ViewIntroAdapterPart.java:114)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.lambda$0(ViewIntroAdapterPart.java:71)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:147)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4580)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.ui.internal.WorkbenchIntroManager.setIntroStandby(WorkbenchIntroManager.java:203)
	at org.eclipse.ui.internal.WorkbenchIntroManager.showIntro(WorkbenchIntroManager.java:141)
	at org.eclipse.ui.application.WorkbenchWindowAdvisor.openIntro(WorkbenchWindowAdvisor.java:193)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.openIntro(IDEWorkbenchWindowAdvisor.java:579)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:785)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:1001)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:139)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:95)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:77)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1487)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2534)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:1990)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2038)
	at org.eclipse.ui.internal.Workbench.lambda$11(Workbench.java:1928)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:147)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4580)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:459)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:650)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:560)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:544)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1015)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:675)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1295)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:693)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:693)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1099)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:563)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:151)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:595)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1501)

!ENTRY org.eclipse.core.runtime 4 0 2019-03-18 10:32:08.360
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.epp.mpc.ui/intro/css/marketplace.png
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.epp.mpc.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:203)
	at org.eclipse.jface.resource.URLImageDescriptor.getStream(URLImageDescriptor.java:155)
	at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:123)
	at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:113)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.asDataURL(QuicklinksViewer.java:442)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.asBrowserURL(QuicklinksViewer.java:425)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.access$1(QuicklinksViewer.java:409)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.getImageURL(QuicklinksViewer.java:300)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.processDefinition(QuicklinksViewer.java:228)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.get(QuicklinksViewer.java:179)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer$ModelReader.get(QuicklinksViewer.java:1)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.getQuicklinks(QuicklinksViewer.java:494)
	at org.eclipse.ui.intro.quicklinks.QuicklinksViewer.createContent(QuicklinksViewer.java:348)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroContent(IntroHTMLGenerator.java:721)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:345)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroDiv(IntroHTMLGenerator.java:464)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:339)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroDiv(IntroHTMLGenerator.java:464)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateIntroElement(IntroHTMLGenerator.java:339)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateBodyElement(IntroHTMLGenerator.java:311)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateHTMLElement(IntroHTMLGenerator.java:146)
	at org.eclipse.ui.internal.intro.impl.html.IntroHTMLGenerator.generateHTMLforPage(IntroHTMLGenerator.java:80)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.generateContentForPage(BrowserIntroPartImplementation.java:326)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.dynamicStandbyStateChanged(BrowserIntroPartImplementation.java:585)
	at org.eclipse.ui.internal.intro.impl.presentations.BrowserIntroPartImplementation.doStandbyStateChanged(BrowserIntroPartImplementation.java:780)
	at org.eclipse.ui.internal.intro.impl.model.AbstractIntroPartImplementation.standbyStateChanged(AbstractIntroPartImplementation.java:256)
	at org.eclipse.ui.internal.intro.impl.model.IntroPartPresentation.standbyStateChanged(IntroPartPresentation.java:445)
	at org.eclipse.ui.intro.config.CustomizableIntroPart.standbyStateChanged(CustomizableIntroPart.java:277)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.lambda$1(ViewIntroAdapterPart.java:117)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.setStandby(ViewIntroAdapterPart.java:114)
	at org.eclipse.ui.internal.ViewIntroAdapterPart.lambda$0(ViewIntroAdapterPart.java:71)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:147)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4580)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.ui.internal.WorkbenchIntroManager.setIntroStandby(WorkbenchIntroManager.java:203)
	at org.eclipse.ui.internal.WorkbenchIntroManager.showIntro(WorkbenchIntroManager.java:141)
	at org.eclipse.ui.application.WorkbenchWindowAdvisor.openIntro(WorkbenchWindowAdvisor.java:193)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.openIntro(IDEWorkbenchWindowAdvisor.java:579)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:785)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:1001)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:139)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:95)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:77)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1487)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2534)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:1990)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2038)
	at org.eclipse.ui.internal.Workbench.lambda$11(Workbench.java:1928)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:147)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4580)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:459)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:650)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:560)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:544)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1015)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:675)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1295)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:693)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:693)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:140)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:689)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1099)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:563)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:151)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:595)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1501)

!ENTRY org.eclipse.egit.ui 2 0 2019-03-18 10:32:19.437
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\mine12'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-03-18 10:32:39.755
!MESSAGE No repository found at file:/C:/Users/mine12/eclipse/java-photon/eclipse/configuration/org.eclipse.osgi/194/data/listener_1925729951/.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2019-03-18 10:33:06.417
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'C:\Users\mine12\eclipse\java-photon\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2019-03-18 22:29:16.071 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-18 22:29:25.563
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-18 22:29:25.566
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-18 22:29:43.186
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-18 22:29:46.848
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2019-03-18 22:29:47.063
!MESSAGE Removing part descriptor with the 'org.eclipse.recommenders.apidocs.rcp.views.apidocs' id and the 'Augmented Docs' description. Points to the invalid 'bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView' class.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2019-03-18 22:29:53.548
!MESSAGE Removing part descriptor with the 'org.eclipse.recommenders.models.rcp.views.projectCoordinates' id and the 'Project Coordinates' description. Points to the invalid 'bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView' class.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2019-03-18 22:29:55.028
!MESSAGE Removing part descriptor with the 'org.eclipse.recommenders.models.rcp.views.modelRepositories' id and the 'Model Repositories' description. Points to the invalid 'bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView' class.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2019-03-18 22:29:55.149
!MESSAGE Removing part descriptor with the 'org.eclipse.recommenders.models.rcp.views.dependencyOverview' id and the 'Dependency Overview' description. Points to the invalid 'bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView' class.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2019-03-18 22:29:55.152
!MESSAGE Removing part descriptor with the 'org.eclipse.recommenders.snipmatch.rcp.views.snippets' id and the 'Snippets' description. Points to the invalid 'bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView' class.
!SESSION 2019-03-20 23:10:48.201 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:10:58.499
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:10:58.504
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:11:17.646
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-20 23:11:22.294
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.core 4 0 2019-03-20 23:12:14.047
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: An error occurred while downloading http://download.eclipse.org/oomph/updates/milestone/latest/compositeContent.jar. The cache file C:\Users\Ptolemy\.p2\org.eclipse.equinox.p2.repository\cache\downloading\compositeContent1263281494.jar could not be renamed to C:\Users\Ptolemy\.p2\org.eclipse.equinox.p2.repository\cache\compositeContent1263281494.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:431)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:262)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.doLoad(LoadMetadataRepositoryJob.java:121)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.runModal(LoadMetadataRepositoryJob.java:106)
	at org.eclipse.equinox.internal.p2.ui.sdk.PreloadingRepositoryHandler$1.runModal(PreloadingRepositoryHandler.java:84)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:190)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.repository 4 0 2019-03-20 23:12:14.051
!MESSAGE An error occurred while downloading http://download.eclipse.org/oomph/updates/milestone/latest/compositeContent.jar. The cache file C:\Users\Ptolemy\.p2\org.eclipse.equinox.p2.repository\cache\downloading\compositeContent1263281494.jar could not be renamed to C:\Users\Ptolemy\.p2\org.eclipse.equinox.p2.repository\cache\compositeContent1263281494.jar.

!ENTRY org.eclipse.help.base 2 0 2019-03-20 23:15:09.207
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.wst.dtdeditor.doc.user_1.1.0.v201802171654 [427]'. The index should be rebuilt with Lucene 7.0.0

!ENTRY org.eclipse.help.base 2 0 2019-03-20 23:15:09.342
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.wst.xmleditor.doc.user_1.1.0.v201802171654 [440]'. The index should be rebuilt with Lucene 7.0.0

!ENTRY org.eclipse.help.base 2 0 2019-03-20 23:15:09.349
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.wst.xsdeditor.doc.user_1.0.800.v201711201733 [443]'. The index should be rebuilt with Lucene 7.0.0

!ENTRY org.eclipse.help.base 2 0 2019-03-20 23:15:09.356
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.wst.sse.doc.user_1.2.0.v201802171654 [430]'. The index should be rebuilt with Lucene 7.0.0

!ENTRY org.eclipse.equinox.p2.core 4 0 2019-03-20 23:16:34.525
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10/categories/site.xml.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadActualSiteFile(UpdateSite.java:239)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.load(UpdateSite.java:150)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:101)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:61)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:168)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.doLoad(LoadMetadataRepositoryJob.java:121)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.runModal(LoadMetadataRepositoryJob.java:106)
	at org.eclipse.equinox.internal.p2.ui.sdk.PreloadingRepositoryHandler$1.runModal(PreloadingRepositoryHandler.java:84)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:190)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:161)
	at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:82)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:278)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:286)
	at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:257)
	at org.apache.http.impl.conn.AbstractClientConnAdapter.receiveResponseHeader(AbstractClientConnAdapter.java:230)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:684)
	at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)
	at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1084)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:1075)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:1071)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	... 1 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:16:34.529
!MESSAGE Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10/categories/site.xml.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:161)
	at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:82)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:278)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:286)
	at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:257)
	at org.apache.http.impl.conn.AbstractClientConnAdapter.receiveResponseHeader(AbstractClientConnAdapter.java:230)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:684)
	at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)
	at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1084)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:1075)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:1071)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.core 4 0 2019-03-20 23:16:34.533
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10.
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:187)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.doLoad(LoadMetadataRepositoryJob.java:121)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.runModal(LoadMetadataRepositoryJob.java:106)
	at org.eclipse.equinox.internal.p2.ui.sdk.PreloadingRepositoryHandler$1.runModal(PreloadingRepositoryHandler.java:84)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:190)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10/categories/site.xml.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadActualSiteFile(UpdateSite.java:239)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.load(UpdateSite.java:150)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:101)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:61)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:168)
	... 19 more
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:161)
	at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:82)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:278)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:286)
	at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:257)
	at org.apache.http.impl.conn.AbstractClientConnAdapter.receiveResponseHeader(AbstractClientConnAdapter.java:230)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:684)
	at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)
	at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1084)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:1075)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:1071)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	... 1 more
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1002 2019-03-20 23:16:34.534
!MESSAGE Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10.
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10/categories/site.xml.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadActualSiteFile(UpdateSite.java:239)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.load(UpdateSite.java:150)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:101)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:61)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:168)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:117)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:409)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:201)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:476)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.doLoad(LoadMetadataRepositoryJob.java:121)
	at org.eclipse.equinox.p2.ui.LoadMetadataRepositoryJob.runModal(LoadMetadataRepositoryJob.java:106)
	at org.eclipse.equinox.internal.p2.ui.sdk.PreloadingRepositoryHandler$1.runModal(PreloadingRepositoryHandler.java:84)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:190)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:161)
	at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:82)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:278)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:286)
	at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:257)
	at org.apache.http.impl.conn.AbstractClientConnAdapter.receiveResponseHeader(AbstractClientConnAdapter.java:230)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:684)
	at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)
	at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1084)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:1075)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:1071)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	... 1 more
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:16:34.535
!MESSAGE Unable to read repository at http://download.eclipse.org/eclipse/updates/4.10/categories/site.xml.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:161)
	at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:82)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:278)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:286)
	at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:257)
	at org.apache.http.impl.conn.AbstractClientConnAdapter.receiveResponseHeader(AbstractClientConnAdapter.java:230)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:684)
	at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)
	at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1084)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:1075)
	at org.eclipse.ecf.provider.filetransfer.httpclient4.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:1071)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.engine 4 4 2019-03-20 23:24:48.851
!MESSAGE An error occurred while committing the engine session for profile: C__Users_Ptolemy_eclipse_java-2018-12_eclipse.
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2019-03-20 23:24:48.851
!MESSAGE An error occurred while undoing the org.eclipse.equinox.internal.p2.engine.phases.Collect phase.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.equinox.internal.p2.engine.EngineSession.getProfileDataDirectory(EngineSession.java:81)
	at org.eclipse.equinox.internal.p2.engine.Phase.prePerform(Phase.java:117)
	at org.eclipse.equinox.internal.p2.engine.EngineSession.rollBackPhase(EngineSession.java:233)
	at org.eclipse.equinox.internal.p2.engine.EngineSession.rollback(EngineSession.java:182)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:89)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:178)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:190)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2019-03-20 23:27:04.606 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:27:20.826
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:27:20.829
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-20 23:27:39.237
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-20 23:27:43.200
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.security 1 0 2019-03-20 23:28:47.140
!MESSAGE New keyring password generated. 

!ENTRY org.eclipse.egit.ui 4 0 2019-03-20 23:28:57.387
!MESSAGE https://github.com/Ptolemy2002/Java-code.git: not authorized
!STACK 1
org.eclipse.core.runtime.CoreException: https://github.com/Ptolemy2002/Java-code.git: not authorized
	at org.eclipse.egit.ui.internal.fetch.FetchOperationUI.execute(FetchOperationUI.java:113)
	at org.eclipse.egit.ui.internal.fetch.FetchOperationUI$1.performJob(FetchOperationUI.java:136)
	at org.eclipse.egit.ui.internal.jobs.RepositoryJob.run(RepositoryJob.java:59)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.jgit.api.errors.TransportException: https://github.com/Ptolemy2002/Java-code.git: not authorized
	at org.eclipse.jgit.api.FetchCommand.call(FetchCommand.java:254)
	at org.eclipse.egit.core.op.FetchOperation.run(FetchOperation.java:134)
	at org.eclipse.egit.ui.internal.fetch.FetchOperationUI.execute(FetchOperationUI.java:110)
	... 3 more
Caused by: org.eclipse.jgit.errors.TransportException: https://github.com/Ptolemy2002/Java-code.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:544)
	at org.eclipse.jgit.transport.TransportHttp.openFetch(TransportHttp.java:362)
	at org.eclipse.jgit.transport.FetchProcess.executeImp(FetchProcess.java:138)
	at org.eclipse.jgit.transport.FetchProcess.execute(FetchProcess.java:124)
	at org.eclipse.jgit.transport.Transport.fetch(Transport.java:1271)
	at org.eclipse.jgit.api.FetchCommand.call(FetchCommand.java:243)
	... 5 more
!SUBENTRY 1 org.eclipse.egit.ui 4 0 2019-03-20 23:28:57.394
!MESSAGE https://github.com/Ptolemy2002/Java-code.git: not authorized
!STACK 0
org.eclipse.jgit.api.errors.TransportException: https://github.com/Ptolemy2002/Java-code.git: not authorized
	at org.eclipse.jgit.api.FetchCommand.call(FetchCommand.java:254)
	at org.eclipse.egit.core.op.FetchOperation.run(FetchOperation.java:134)
	at org.eclipse.egit.ui.internal.fetch.FetchOperationUI.execute(FetchOperationUI.java:110)
	at org.eclipse.egit.ui.internal.fetch.FetchOperationUI$1.performJob(FetchOperationUI.java:136)
	at org.eclipse.egit.ui.internal.jobs.RepositoryJob.run(RepositoryJob.java:59)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.jgit.errors.TransportException: https://github.com/Ptolemy2002/Java-code.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:544)
	at org.eclipse.jgit.transport.TransportHttp.openFetch(TransportHttp.java:362)
	at org.eclipse.jgit.transport.FetchProcess.executeImp(FetchProcess.java:138)
	at org.eclipse.jgit.transport.FetchProcess.execute(FetchProcess.java:124)
	at org.eclipse.jgit.transport.Transport.fetch(Transport.java:1271)
	at org.eclipse.jgit.api.FetchCommand.call(FetchCommand.java:243)
	... 5 more

!ENTRY org.eclipse.ui 4 4 2019-03-20 23:30:25.824
!MESSAGE Unable to create part
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2019-03-20 23:30:25.825
!MESSAGE Cannot determine URI for '/Blackjack/src/main/Tools.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/Blackjack/src/main/Tools.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1013)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1277)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4167)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:260)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1476)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2573)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2546)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1423)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3135)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:440)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:356)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$4(WorkbenchWindow.java:2249)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2247)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3152)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3177)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:365)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:345)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:1001)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:139)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:411)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:333)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:193)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:108)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:77)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:59)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1015)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:675)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:781)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:752)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:746)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:730)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1295)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.lambda$0(LazyStackRenderer.java:75)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:147)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4580)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:177)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1360)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1591)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1543)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditors(WorkbenchPage.java:1513)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:1637)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$3(AbstractTextEditor.java:4262)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3919)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3550)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:168)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:639)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:148)
	at org.eclipse.ltk.ui.refactoring.resource.DeleteResourcesWizard$DeleteResourcesRefactoringConfigurationPage.performFinish(DeleteResourcesWizard.java:285)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:713)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:450)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:622)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4131)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1055)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3944)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3547)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:822)
	at org.eclipse.jface.window.Window.open(Window.java:798)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:192)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:212)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.ltk.internal.ui.refactoring.actions.DeleteResourcesHandler.execute(DeleteResourcesHandler.java:44)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:294)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:96)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:320)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:254)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:164)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:497)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:490)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommandInContext(LegacyHandlerService.java:455)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.runCommand(LTKLauncher.java:99)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.openDeleteWizard(LTKLauncher.java:51)
	at org.eclipse.ui.actions.DeleteResourceAction.run(DeleteResourceAction.java:452)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.DeleteAction.run(DeleteAction.java:197)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:476)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:568)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4131)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1055)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3944)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3547)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:563)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:151)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:595)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1501)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2019-03-20 23:30:25.829
!MESSAGE Cannot determine URI for '/Blackjack/src/main/Tools.java'.

!ENTRY org.eclipse.core.resources 4 1 2019-03-20 23:35:23.308
!MESSAGE Problems occurred while refreshing local changes
!SUBENTRY 1 org.eclipse.core.resources 4 1 2019-03-20 23:35:23.308
!MESSAGE Problems occurred while refreshing local changes
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Errors occurred while refreshing resources with the local file system.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:979)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:959)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1550)
	at org.eclipse.core.internal.resources.File.refreshLocal(File.java:319)
	at org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace(RefreshJob.java:166)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: The project description file (.project) for 'Blackjack' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
java.lang.Exception: The project description file (.project) for 'Blackjack' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.Project.updateDescription(Project.java:1344)
	at org.eclipse.core.internal.resources.File.updateMetadataFiles(File.java:382)
	at org.eclipse.core.internal.localstore.RefreshLocalVisitor.visit(RefreshLocalVisitor.java:291)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:118)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:976)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:959)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1550)
	at org.eclipse.core.internal.resources.File.refreshLocal(File.java:319)
	at org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace(RefreshJob.java:166)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.core.resources 4 271 2019-03-20 23:35:23.309
!MESSAGE Errors occurred while refreshing resources with the local file system.
!SUBENTRY 3 org.eclipse.core.resources 4 567 2019-03-20 23:35:23.309
!MESSAGE The project description file (.project) for 'Blackjack' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Blackjack' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.Project.updateDescription(Project.java:1344)
	at org.eclipse.core.internal.resources.File.updateMetadataFiles(File.java:382)
	at org.eclipse.core.internal.localstore.RefreshLocalVisitor.visit(RefreshLocalVisitor.java:291)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:118)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:976)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:959)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1550)
	at org.eclipse.core.internal.resources.File.refreshLocal(File.java:319)
	at org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace(RefreshJob.java:166)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 2 2 2019-03-20 23:35:49.433
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2019-03-20 23:35:49.434
!MESSAGE The project description file (.project) for 'Blackjack' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.equinox.p2.engine 4 4 2019-03-20 23:37:51.491
!MESSAGE An error occurred while collecting items to be installed
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2019-03-20 23:37:51.491
!MESSAGE session context was:(profile=C__Users_Ptolemy_eclipse_java-2018-12_eclipse, phase=org.eclipse.equinox.internal.p2.engine.phases.Collect, operand=, action=).
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1002 2019-03-20 23:37:51.491
!MESSAGE Multiple problems occurred while downloading.
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.491
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.eclipse.egit.doc_5.3.0.201903130848-r.jar.pack.gz.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.492
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.eclipse.egit.doc_5.3.0.201903130848-r.jar.
!STACK 0
org.apache.http.ConnectionClosedException: Premature end of Content-Length delimited message body (expected: 4702219; received: 271259
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:178)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1002 2019-03-20 23:37:51.492
!MESSAGE Multiple problems occurred while downloading.
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.492
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.bouncycastle.bcprov_1.60.0.v20181210-2057.jar.pack.gz.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.493
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.bouncycastle.bcprov_1.60.0.v20181210-2057.jar.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.493
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/features/org.eclipse.jgit_5.3.0.201903130848-r.jar.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.engine 4 4 2019-03-20 23:37:51.495
!MESSAGE An error occurred while collecting items to be installed
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2019-03-20 23:37:51.495
!MESSAGE session context was:(profile=C__Users_Ptolemy_eclipse_java-2018-12_eclipse, phase=org.eclipse.equinox.internal.p2.engine.phases.Collect, operand=, action=).
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1002 2019-03-20 23:37:51.495
!MESSAGE Multiple problems occurred while downloading.
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.495
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.eclipse.egit.doc_5.3.0.201903130848-r.jar.pack.gz.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.495
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.eclipse.egit.doc_5.3.0.201903130848-r.jar.
!STACK 0
org.apache.http.ConnectionClosedException: Premature end of Content-Length delimited message body (expected: 4702219; received: 271259
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:178)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1002 2019-03-20 23:37:51.495
!MESSAGE Multiple problems occurred while downloading.
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.495
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.bouncycastle.bcprov_1.60.0.v20181210-2057.jar.pack.gz.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.495
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/plugins/org.bouncycastle.bcprov_1.60.0.v20181210-2057.jar.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2019-03-20 23:37:51.495
!MESSAGE Unable to read repository at http://download.eclipse.org/egit/updates/features/org.eclipse.jgit_5.3.0.201903130848-r.jar.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:201)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:176)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135)
	at java.io.FilterInputStream.read(Unknown Source)
	at java.io.FilterInputStream.read(Unknown Source)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:178)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.egit.core 4 0 2019-03-21 00:01:50.821
!MESSAGE An exception occurred during push on URI file:///C:\Users\Ptolemy\Desktop\Java Code\Blackjack Game\.git: Nothing to push.
!STACK 0
org.eclipse.jgit.errors.TransportException: Nothing to push.
	at org.eclipse.jgit.transport.Transport.push(Transport.java:1334)
	at org.eclipse.egit.core.op.PushOperation.run(PushOperation.java:191)
	at org.eclipse.egit.ui.internal.push.PushJob.performJob(PushJob.java:86)
	at org.eclipse.egit.ui.internal.jobs.RepositoryJob.run(RepositoryJob.java:59)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.egit.ui 4 0 2019-03-21 00:01:50.825
!MESSAGE Can't connect to any repository: file:///C:\Users\Ptolemy\Desktop\Java Code\Blackjack Game\.git (Nothing to push.)
!SESSION 2019-03-21 00:16:09.508 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 00:16:19.074
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 00:16:19.078
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 00:16:32.827
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-21 00:16:37.159
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 0 2019-03-21 00:17:15.601
!MESSAGE Unexpected error loading extension: org.eclipse.equinox.p2.metadata.repository.XZedRepository
!STACK 0
java.lang.NullPointerException
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:417)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:378)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:102)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:158)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:405)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCacheFromFile(CacheManager.java:135)
	at org.eclipse.equinox.internal.p2.metadata.repository.XZedSimpleMetadataRepositoryFactory.getLocalFile(XZedSimpleMetadataRepositoryFactory.java:60)
	at org.eclipse.equinox.internal.p2.metadata.repository.XZedSimpleMetadataRepositoryFactory.load(XZedSimpleMetadataRepositoryFactory.java:80)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:770)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:671)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker.getAvailableRepositories(UpdateChecker.java:152)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker.checkForUpdates(UpdateChecker.java:130)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker$UpdateCheckThread.run(UpdateChecker.java:78)

!ENTRY org.eclipse.equinox.p2.updatechecker 4 0 2019-03-21 00:17:15.607
!MESSAGE Exception in update check thread
!STACK 0
java.lang.NullPointerException
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.findMatchingRepositoryExtensions(AbstractRepositoryManager.java:407)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:765)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:671)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker.getAvailableRepositories(UpdateChecker.java:152)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker.checkForUpdates(UpdateChecker.java:130)
	at org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker$UpdateCheckThread.run(UpdateChecker.java:78)
!SESSION 2019-03-21 16:59:14.316 -----------------------------------------------
eclipse.buildId=4.10.0.I20181206-0815
java.version=1.8.0_201
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 16:59:26.871
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.poll.PollNewsFeedsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 16:59:26.876
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.read.ReadNewsItemsHandler

!ENTRY org.eclipse.e4.ui.workbench 4 0 2019-03-21 16:59:40.192
!MESSAGE Unable to retrieve the bundle from the URI: bundleclass://org.eclipse.recommenders.news.rcp/org.eclipse.recommenders.internal.news.rcp.toolbar.NewsToolControl

!ENTRY org.eclipse.egit.ui 2 0 2019-03-21 16:59:43.150
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ptolemy'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 4 0 2019-03-21 17:36:26.336
!MESSAGE Checking out files failed
!STACK 0
org.eclipse.jgit.api.errors.JGitInternalException: Unmerged path: .metadata/.log
	at org.eclipse.jgit.api.CheckoutCommand$1.apply(CheckoutCommand.java:502)
	at org.eclipse.jgit.dircache.DirCacheEditor.applyEdits(DirCacheEditor.java:181)
	at org.eclipse.jgit.dircache.DirCacheEditor.finish(DirCacheEditor.java:134)
	at org.eclipse.jgit.dircache.BaseDirCacheEditor.commit(BaseDirCacheEditor.java:276)
	at org.eclipse.jgit.dircache.DirCacheEditor.commit(DirCacheEditor.java:127)
	at org.eclipse.jgit.api.CheckoutCommand.checkoutPathsFromIndex(CheckoutCommand.java:514)
	at org.eclipse.jgit.api.CheckoutCommand.checkoutPaths(CheckoutCommand.java:449)
	at org.eclipse.jgit.api.CheckoutCommand.call(CheckoutCommand.java:209)
	at org.eclipse.egit.ui.internal.staging.StagingView$ReplaceAction.replaceWith(StagingView.java:3075)
	at org.eclipse.egit.ui.internal.staging.StagingView$ReplaceAction.run(StagingView.java:3120)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:476)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:568)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4131)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1055)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3944)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3547)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:563)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:151)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:595)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1501)
Caused by: org.eclipse.jgit.errors.UnmergedPathException: Unmerged path: .metadata/.log
	at org.eclipse.jgit.api.CheckoutCommand$1.apply(CheckoutCommand.java:500)
	... 38 more
